# L0Proof - Система верифицируемых ценовых оракулов для активов

L0Proof - это децентрализованное решение для предоставления проверяемых данных о ценах активов в блокчейне с минимальными затратами на газ. Система позволяет смарт-контрактам получать доступ к актуальным ценовым данным без необходимости постоянных обновлений в блокчейне, значительно снижая комиссии за газ при сохранении достоверности данных.

## Обзор

Традиционные блокчейн-оракулы часто требуют частых обновлений в сети для предоставления свежих ценовых данных, что приводит к высоким затратам на газ. L0Proof решает эту проблему, реализуя систему подписания данных вне сети блокчейн, где доверенные оракулы подтверждают ценовые данные, которые затем могут использоваться в блокчейне только при необходимости.

### Ключевые особенности

- **Минимальное использование газа**: Ценовые данные отправляются в блокчейн только когда они фактически нужны для транзакции
- **Проверяемые данные**: Подход с множественной подписью обеспечивает целостность данных
- **Актуальное ценообразование**: Свежие котировки доступны с настраиваемой частотой обновления

## Архитектура системы

L0Proof состоит из трех основных компонентов:

### 1. Bootstrap нода

Bootstrap нода служит центральным координатором, который:

- Собирает ценовые данные из нескольких внешних источников (API, биржи)
- Рассчитывает среднюю цену активов
- Формирует пакеты данных с временными метками
- Распределяет ценовые данные валидаторам для подписания
- Предоставляет RPC API для клиентов для получения подписанных котировок
- Поддерживает хранилище исторических данных

**Техническая реализация:**
- Написана на Go с использованием libp2p для P2P-коммуникации
- Реализует модель публикации/подписки для распределения данных валидаторам
- Использует LevelDB для постоянного хранения котировок и подписей
- Настраиваемые источники данных и интервалы сбора

### 2. Ноды-валидаторы

**Подразумевается, что ноды работают на отдельных независимых серверах**

Ноды-валидаторы отвечают за:

- Подключение к P2P сети для обмена сообщениями
- Получение запросов на подписание ценовых данных
- Подписание данных своими приватными ключами
- Публикацию подписей обратно в сеть
- Обеспечение децентрализованного уровня доверия

**Техническая реализация:**
- Написаны на Go с использованием libp2p для P2P-коммуникации
- Используют Ethereum-совместимое подписание (secp256k1)
- Автоматическое переподключение к bootstrap-ноде при разрыве соединения

### 3. Смарт-контракты

`В директории contracts есть отдельный README`

Слой смарт-контрактов обеспечивает:

- Проверку подписей ценовых данных в блокчейне
- Реестр доверенных адресов валидаторов
- Настраиваемое окно действительности для ценовых котировок

**Техническая реализация:**
- Написан на Solidity для совместимости с EVM
  - `OracleVerifier`: Обрабатывает проверку подписей и управляет доверенными оракулами
  - `AssetTradingWithQuotes`: Пример контракта, показывающий, как можно использовать проверенные ценовые котировки на практике

## Как это работает

1. **Сбор данных**: Bootstrap-нода периодически собирает ценовые данные из различных источников и рассчитывает средние цены
2. **Распределение данных**: Ценовые данные распределяются валидаторам через P2P-сеть
3. **Процесс подписания**: Ноды-валидаторы подписывают данные и публикуют свои подписи
4. **Доступ через API**: Клиенты запрашивают у API bootstrap-ноды последние подписанные ценовые данные
5. **Проверка в блокчейне**: Подписанные данные отправляются в смарт-контракт, смарт-контракт обращается в OracleVerifier для верификации
6. **Использование данных**: Если проверка проходит успешно, контракт может использовать ценовые данные для своих операций
7. **Исторический доступ**: Все исторические котировки сохраняются и могут быть получены для аудита

## Начало работы

### Предварительные требования

- Docker и Docker Compose
- Node.js и npm (для фронтенда и развертывания контрактов)
- Кошелек в Siberium или BSC Testnet с тестовыми токенами (для взаимодействия с контрактами)

### Запуск системы

Всю систему можно запустить с помощью Docker Compose:

```bash
docker-compose up --build -d
```

Или вы можете запустить каждый компонент отдельно, предварительно настроив .env (как в .env.example)

#### Bootstrap нода

```bash
cd bootstrap
cp .env.example .env
# Настройте .env
go run .
```

#### Нода-валидатор

```bash
cd node
cp .env.example .env
# Настройте .env
go run .
```

#### Смарт-контракты

```bash
cd contract
cp .env.example .env
# Настройте .env
npm install
npx hardhat compile
npx hardhat deploy --network siberium
```

#### Фронтенд

```bash
cd frontend
npm install
npm run dev
```

## Связь

TG: shipicin_max
